#windows查看服务的命令：services.msc
官方文档:http://www.rabbitmq.com/getstarted.html
Python学习:http://book.pythontips.com/en/latest/args_and_kwargs.html

rabbitmqctl list_queues:
rabbitmqctl list_exchanges:
rabbitmqctl list_bindings:


1、简述 RabbitMQ、Kafka、ZeroMQ的区别？

2、RabbitMQ如何在消费者获取任务后未处理完前就挂掉时，保证数据不丢失？

3、RabbitMQ如何对消息做持久化？

4、RabbitMQ如何控制消息被消费的顺序？

5、以下RabbitMQ的exchange type分别代表什么意思？如：fanout、direct、topic。

1-介绍:如何发送和接收来自命名队列的消息
RabbitMQ是一个消息代理：它接受和转发消息。
队列:本质上是一个很大的消息缓冲区,许多生产者可以发送进入一个队列的消息，并且许多消费者可以尝试从一个队列接收数据。

channel.basic_publish（exchange = ''，
                      routing_key = 'hello'，
                      body = 'Hello World！' ):
在RabbitMQ中，消息永远不会直接发送到队列，它总是需要经过交换。
我们现在需要知道的是如何使用由空字符串标识的默认交换。这种交换是特殊的 - 它允许我
们准确地指定消息应该到达哪个队列。队列名称需要在routing_key参数中指定。

我们可以根据需要多次运行该命令，并且只会创建一个。

您可能会问为什么我们再次声明队列 - 我们已经在之前的代码中声明了它。如果我们确信队列已经存在，
我们可以避免这种情况。例如，如果send.py程序之前运行过。但我们还不确定首先运行哪个程序。
在这种情况下，重复在两个程序中重复声明队列是一种很好的做法。


工作队列（又名：任务队列）背后的主要思想是避免立即执行资源密集型任务，并且必须等待完成。
相反，我们安排稍后完成任务。我们将任务封装 为消息并将其发送到队列。在后台运行的工作进程将
弹出任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享。

RabbitMQ默认的消息分发机制:
默认情况下，RabbitMQ将按顺序将每条消息发送给下一个使用者。
平均而言，每个消费者将获得相同数量的消息。这种分配消息的方式称为循环法.（我们可以详细知道谁都干了什么活.）

no_ack =True带来的负面:
用我们目前的代码，一旦RabbitMQ将消息传递给客户，它立即将其标记为删除。
在这种情况下，如果你杀了一个工人，我们将失去刚刚处理的信息。
我们也会失去所有派发给这个特定工作人员但尚未处理的消息。

no_ack = False:
为了确保消息永不丢失，RabbitMQ支持 消息确认。消费者发回ack（请求）
告诉RabbitMQ已经收到，处理了特定的消息，并且RabbitMQ可以自由删除它。
如果消费者死亡（其通道关闭，连接关闭或TCP连接丢失），RabbitMQ将理解消息
未被完全处理，并将重新排队。**如果有其他消费者同时在线，它会迅速将其重新发送给另一
位消费者。这样，即使工作人员偶尔死亡，也可以确保没有任何信息丢失。
没有任何消息超时; 当消费者死亡时，RabbitMQ将重新传递消息。即使处理消息需要
非常很长的时间也没关系。

如何确保即使消费者死亡，任务也不会丢失??(面试题)
具体代码:
ch.basic_ack(delivery_tag=method.delivery_tag)  ===> 返回确认操作.
no_ack = False（要求必须确认.）
缺陷:但是如果RabbitMQ服务器停止，我们的任务仍然会丢失。???

<Basic.Deliver(['consumer_tag=ctag1.81499d951a364d62acb3615072659a5c',
                'delivery_tag=1',
                'exchange=',
                'redelivered=False',
                'routing_key=queue_2'])>



问题:如果RabbitMQ服务器停止，如何确保我们的任务不会丢失?
当RabbitMQ退出或崩溃时，它会忘记队列和消息，除非您告诉它不要。
需要做两件事来确保消息不会丢失：我们需要将队列和消息标记为持久。

队列持久化的方法:（如果队列之前已经存在的话,这个声明将失效：RabbitMQ不允许您使用不同的参数重新定义现有的队列）
channel.queue_declare（queue = 'hello'，durable = True）===>生产者和消费者需要同时更改.

消息持久化的方法:
我们需要将消息标记为持久 - 通过提供值为2的delivery_mode属性.
channel.basic_publish(exchange='',
                      routing_key="task_queue",
                      body=message,
                      properties=pika.BasicProperties(
                         delivery_mode = 2, # make message persistent
                      ))

总结:消费者死掉的处理方法与RabbitMq服务器死掉的处理方法:


公平消息分发的一个问题:
RabbitMq默认的消息处理机制:RabbitMQ不知道任何有关这一点，并仍将均匀地发送消息。
因为RabbitMQ只在消息进入队列时调度消息。它没有考虑消费者未确认消息的数量。
RabbitMQ只是盲目地将第n条消息分发给第n个消费者。（牛逼的一句话.）即每个任务只被传递给一个工作人员。

prefetch_count = 1设置。这告诉RabbitMQ一次不要向工作人员发送多个消息。
或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。相反，
它会将其分派给不是仍然忙碌的下一个工作人员。

不要向工作人员发送新消息，直到它处理并确认了前一个消息.**


发布:基本上，发布的日志消息将被广播给所有的接收者。
简单模型汇总：
甲生产者是发送消息的用户的应用程序。
甲队列是存储消息的缓冲器。
甲消费者是接收消息的用户的应用程序。

RabbitMQ的消息传递模型:
RabbitMQ中的消息传递模型的核心思想是生产者永远不会将任何消息直接发送到队列中。
实际上，生产者通常甚至不知道邮件是否会被传送到任何队列中,相反，制作人只能发送消息给交易所。

exchange的作用:
交换是一件非常简单的事情。一方面它接收来自生产者的消息，另一方则推动他们排队。
交易所必须知道如何处理收到的消息。是否应该附加到特定队列？它应该附加到许多队列中吗？
或者它应该被丢弃。这些规则由交换类型定义。
之前我们使用了Exchange: (AMQP default)：因为我们使用了一个默认的交换，我们用空字符串（“”）来标识。

广播的机制:它只是将收到的所有消息广播到它所知道的所有队列中。这正是我们记录器所需要的。
注意：我们需要在发送时提供一个routing_key，但是对于扇出交换，它的值将被忽略 **

该交换参数''是交易所的名称。空字符串表示默认或无名交换：使用routing_key指定的名称
（如果存在）将消息路由到队列。

如何让:让服务器为我们选择一个随机队列名称。我们可以通过不将队列参数提供给queue_declare来实现这一点？
result = channel.queue_declare(exclusive=True)
result.method.queue是队列的名字.

交换和队列之间的关系称为绑定:
channel.queue_bind（exchange = 'logs'，
                   队列= result.method.queue）


#如果没有队列绑定到exchange:
如果没有队列绑定到交换机上，这些消息将会丢失，但这对我们来说没问题;
如果没有消费者正在收听，我们可以放心地丢弃消息。


#第一:持久化问题测试.
#queue自动删除问题
#随机队列问题
#整合问题????


























