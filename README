#windows查看服务的命令：services.msc
官方文档:http://www.rabbitmq.com/getstarted.html

1、简述 RabbitMQ、Kafka、ZeroMQ的区别？

2、RabbitMQ如何在消费者获取任务后未处理完前就挂掉时，保证数据不丢失？

3、RabbitMQ如何对消息做持久化？

4、RabbitMQ如何控制消息被消费的顺序？

5、以下RabbitMQ的exchange type分别代表什么意思？如：fanout、direct、topic。

1-介绍:如何发送和接收来自命名队列的消息
RabbitMQ是一个消息代理：它接受和转发消息。
队列:本质上是一个很大的消息缓冲区,许多生产者可以发送进入一个队列的消息，并且许多消费者可以尝试从一个队列接收数据。

channel.basic_publish（exchange = ''，
                      routing_key = 'hello'，
                      body = 'Hello World！' ):
在RabbitMQ中，消息永远不会直接发送到队列，它总是需要经过交换。
我们现在需要知道的是如何使用由空字符串标识的默认交换。这种交换是特殊的 - 它允许我
们准确地指定消息应该到达哪个队列。队列名称需要在routing_key参数中指定。

我们可以根据需要多次运行该命令，并且只会创建一个。

您可能会问为什么我们再次声明队列 - 我们已经在之前的代码中声明了它。如果我们确信队列已经存在，
我们可以避免这种情况。例如，如果send.py程序之前运行过。但我们还不确定首先运行哪个程序。
在这种情况下，重复在两个程序中重复声明队列是一种很好的做法。


工作队列（又名：任务队列）背后的主要思想是避免立即执行资源密集型任务，并且必须等待完成。
相反，我们安排稍后完成任务。我们将任务封装 为消息并将其发送到队列。在后台运行的工作进程将
弹出任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享。

RabbitMQ默认的消息分发机制:
默认情况下，RabbitMQ将按顺序将每条消息发送给下一个使用者。
平均而言，每个消费者将获得相同数量的消息。这种分配消息的方式称为循环法.（我们可以详细知道谁都干了什么活.）

no_ack =True带来的负面:
用我们目前的代码，一旦RabbitMQ将消息传递给客户，它立即将其标记为删除。
在这种情况下，如果你杀了一个工人，我们将失去刚刚处理的信息。
我们也会失去所有派发给这个特定工作人员但尚未处理的消息。

no_ack = False:
为了确保消息永不丢失，RabbitMQ支持 消息确认。消费者发回ack（请求）
告诉RabbitMQ已经收到，处理了特定的消息，并且RabbitMQ可以自由删除它。
如果消费者死亡（其通道关闭，连接关闭或TCP连接丢失），RabbitMQ将理解消息
未被完全处理，并将重新排队。**如果有其他消费者同时在线，它会迅速将其重新发送给另一
位消费者。这样，即使工作人员偶尔死亡，也可以确保没有任何信息丢失。
没有任何消息超时; 当消费者死亡时，RabbitMQ将重新传递消息。即使处理消息需要
非常很长的时间也没关系。

具体代码:
ch.basic_ack(delivery_tag=method.delivery_tag)
no_ack = False

<Basic.Deliver(['consumer_tag=ctag1.81499d951a364d62acb3615072659a5c',
                'delivery_tag=1',
                'exchange=',
                'redelivered=False',
                'routing_key=queue_2'])>


























